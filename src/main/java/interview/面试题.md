1. 为什么要使用Spring？  
    控制反转（Inversion of Control） 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的依赖注入（Dependency Injection）。
    - IOC:控制反转  
        - 传统的开发是在需要执行某个接口的方法去new一个该接口的实现类，然后操作该类方法。但是如果需要更改实现类。则需要去每一个代码中修改。同时，比如很多的业务逻辑都设计到对Employee的数据库操作，这些操作都在dao中封装，那么我们每次操作数据库，都需要去new一个dao的对象，造成资源的浪费。对于整个应用程序而言，只创建一个Dao对象来操作即可，这可以通过单例模式实现，通过单例模式实现之后，每个类中都需要写单例模式的模版化的代码，代码会比较臃肿。  
        - Spring的IOC容器初始化，默认创建的实例的就是单例的，通过Spring，我们把创建对象的过程抽取出来交给Spring来做，将所有的接口的实例化的过程，全部放在IOC容器中，在程序启动的时候，就已经在容器中new好了所有的对象，在代码中可以直接调用接口的方法。如果需要改变某个实现，需要修改Spring的配置文件即可。  
        - 我们在创建实例的时候不需要了解创建的细节，IOC会从最上层开始往下找依赖关系，到达最底层之后再往上一步一步new，
    - DI:依赖注入
        - 依赖注入（Dependency Injection）来实现控制反转的方式。所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制”。依赖注入的最大好处在于:它消除了MovieLister类对具体MovieFinder实现类的依赖。
    - AOC:面向切面编程
        - 在开发的过程中，有一些逻辑是需要经常被处理的，比如鉴权，比如日志的打印，我们原来的项目在每一段处理业务逻辑的代码中，都需要先鉴权，大量的代码复制粘贴，并且如果更改权限的控制，则需要每段代码中都更改，在开发的过程中出现过需要给某个模块增加鉴权然后全部加班几天的事情。将这些公共的代码抽取出来，通过配置切点，指定在某个方法执行前执行，就可以将鉴权的逻辑抽离出来，便于维护。能大大的提高开发效率。
2. private修饰的方法可以通过反射访问，那么private的意义是什么?  
    答:private的关键字只是访问权限控制符，是面向对象的封装。而不是处理安全问题的。
3. Java类的初始化顺序  
    答:父类的静态变量，父类的静态代码块，子类的静态变量，子类的静态代码块，父类的普通变量，父类的构造器，子类的普通变量，子类的构造器。
4. Java类的加载顺序
    答:
    1. 加载:虚拟机完成三个事情。
        1. 通过一个类的全限定名来获取定义此类的二进制字节流。
        2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
        3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区的各种数据的访问入口
    2. 验证:因为字节码文件并不一定是由Java源码编译过来，甚至可以直接用十六进制编辑器直接编写来产生Class文件。
        1. 文件格式验证，验证字节流是否符合Class文件格式的规范，并能被当前处理机处理。
        2. 元数据验证:对字节码描述的信息进行语义分析，保证描述的信息符合Java语言规范的要求，保证不存在不符合Java语言规范的元数据信息。
        3. 字节码验证:通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。
        4. 符号引用验证:对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，确保解析动作能正确执行。
    3. 准备:这一阶段正式为类变量分配内存并设置类变量初始值，这些变量所使用的内存都将在方法区进行分配。强调两点，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值通常情况下是数据类型的零值（final例外，会直接赋值为123），假设一个类变量的定义为
        > public static int value = 123;                  
那变量的值value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何的Java方法，而把value赋值为123的putstatic指令是程序编译后，存放在类构造器<client>()方法中，所以把value赋值为123的动作将在初始化阶段才会执行。
    4. 解析:
    5. 初始化: