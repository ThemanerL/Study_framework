1. 为什么要使用Spring？  
    控制反转（Inversion of Control） 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的依赖注入（Dependency Injection）。
    - IOC:控制反转  
        - 传统的开发是在需要执行某个接口的方法去new一个该接口的实现类，然后操作该类方法。但是如果需要更改实现类。则需要去每一个代码中修改。同时，比如很多的业务逻辑都设计到对Employee的数据库操作，这些操作都在dao中封装，那么我们每次操作数据库，都需要去new一个dao的对象，造成资源的浪费。对于整个应用程序而言，只创建一个Dao对象来操作即可，这可以通过单例模式实现，通过单例模式实现之后，每个类中都需要写单例模式的模版化的代码，代码会比较臃肿。  
        - Spring的IOC容器初始化，默认创建的实例的就是单例的，通过Spring，我们把创建对象的过程抽取出来交给Spring来做，将所有的接口的实例化的过程，全部放在IOC容器中，在程序启动的时候，就已经在容器中new好了所有的对象，在代码中可以直接调用接口的方法。如果需要改变某个实现，需要修改Spring的配置文件即可。
        - 我们在创建实例的时候不需要了解创建的细节，IOC会从最上层开始往下找依赖关系，到达最底层之后再往上一步一步new。
    - DI:依赖注入
        - 依赖注入（Dependency Injection）来实现控制反转的方式。所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制”。依赖注入的最大好处在于:它消除了MovieLister类对具体MovieFinder实现类的依赖。两种不同的注入方式，需要强制依赖的时候使用构造器参数注入，而可选依赖的时候选用Set方式注入。
    - AOC:面向切面编程
        - 在开发的过程中，有一些逻辑是需要经常被处理的，比如鉴权，比如日志的打印，我们原来的项目在每一段处理业务逻辑的代码中，都需要先鉴权，大量的代码复制粘贴，并且如果更改权限的控制，则需要每段代码中都更改，在开发的过程中出现过需要给某个模块增加鉴权然后全部加班几天的事情。将这些公共的代码抽取出来，通过配置切点，指定在某个方法执行前执行，在程序运行过程中将增强代码织入原代码中（通过代理实现），就可以将鉴权的逻辑抽离出来，便于维护。能大大的提高开发效率。
1. Spring的Bean的作用域  
    答:对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。
    1. singleton
    2. prototype:当一个Bean被设置为prototype 后Spring就不会对一个bean的整个生命周期负责，容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了
    3. request:request作用域，对于每次HTTP请求到达应用程序，Spring容器会创建一个全新的Request作用域的bean实例，且该bean实例仅在当前HTTP request内有效，整个请求过程也只会使用相同的bean实例，因此我们可以根据需要放心的更改所建实例的内部状态，而其他请求HTTP请求则创建新bean的实例互不干扰，当处理请求结束，request作用域的bean实例将被销毁，如在接收参数时可能需要一个bean实例来装载一些参数，显然每次请求参数几乎不会相同，因此希望bean实例每次都是足够新的而且只在request作用域范围内有效
    4. session:每当创建一个新的HTTP Session时就会创建一个Session作用域的Bean，并该实例bean伴随着会话的存在而存在
1. Spring的Autowired如何匹配到bean  
    答:在constructor模式下，存在单个实例则优先按类型进行参数匹配（无论名称是否匹配），当存在多个类型相同实例时，按名称优先匹配，如果没有找到对应名称，则注入失败，此时可以使用autowire-candidate=”false” 过滤来解决。 
1. private修饰的方法可以通过反射访问，那么private的意义是什么?  
    答:private的关键字只是访问权限控制符，是面向对象的封装。而不是处理安全问题的。
1. Java类的初始化顺序  
    答:父类的静态变量，父类的静态代码块，子类的静态变量，子类的静态代码块，父类的普通变量，父类的构造器，子类的普通变量，子类的构造器。
1. Java类的加载顺序
    答:
    1. 加载:虚拟机完成三个事情。
        1. 通过一个类的全限定名来获取定义此类的二进制字节流。
        2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
        3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区的各种数据的访问入口
    2. 验证:因为字节码文件并不一定是由Java源码编译过来，甚至可以直接用十六进制编辑器直接编写来产生Class文件。
        1. 文件格式验证，验证字节流是否符合Class文件格式的规范，并能被当前处理机处理。
        2. 元数据验证:对字节码描述的信息进行语义分析，保证描述的信息符合Java语言规范的要求，保证不存在不符合Java语言规范的元数据信息。
        3. 字节码验证:通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。
        4. 符号引用验证:对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，确保解析动作能正确执行。
    3. 准备:这一阶段正式为类变量分配内存并设置类变量初始值，这些变量所使用的内存都将在方法区进行分配。强调两点，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值通常情况下是数据类型的零值（final例外，会直接赋值为123）。假设一个类变量的定义为
    
        >public static int value = 123;
    
        变量的值value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何的Java方法，而把value赋值为123的putstatic指令是程序编译后，存放在类构造器\<client>()方法中，所以把value赋值为123的动作将在初始化阶段才会执行。
    4. 解析:将常量池的符号引用替换为直接引用的过程。
        - 符号引用:符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存格局无关，引用的目标并不一定已经加载到内存中。
        - 直接引用:直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。
    5. 初始化:初始化阶段才真正开始执行类中定义的Java程序代码。给类变量赋值
        - \<clint>()方法是由编译器自动收起类中所有类变量的复制动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在之前的静态语句块可以赋值，但是不能访问。   
1. 一个A.java文件有3个类ABC，编译后有几个class文件？  
    答:A.class、A$B.class、A$C.class
1. Java里面局部变量需要显式初始化，编译器为什么这样设计？  
    答:大部分局部变量未赋初值属于编程者的失误而非有意，强制程序员提供一个初始值更容易发现BUG。
1. JAVA创建对象的四种方式
    1. 用new语句创建对象，这是最常用的创建对象的方式。
    2. 运用反射手段，调用Java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。
    3. 调用对象的clone()方法。
    4. 运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法.
1. int a=1;是原子操作吗？  
    答: 是的。
1. 可以用for循环直接删除ArrayList的特定元素吗？可能会出现什么问题？怎样解决？
    答:不行。ArrayList的remove操作是将index+1起始的元素复制到index起始的位置，第一次for循环，删除list[0],从list[1]-list[size - 1]全部向前移动一位，第二次for循环，删除list[1]，然而在第一次for循环后此时的list[1]其实是原List的list[2]，原来的list[0]在现在的list[1]的位置，真正想要删除的是原List的list[1]，该元素被跳过了。无法被删除。
1. dispatchServlet怎样分发任务的
![dispatchServlet](https://pic4.zhimg.com/v2-976a59b61d42ddbf93ceb26aa3ba44e6_r.jpg)
    1. 用户发请求-->DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制。
    2. DispatcherServlet-->HandlerMapping，HandlerMapping将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器,多个HandlerInterceptor拦截器)。
    3. DispatcherServlet-->HandlerAdapter,HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器。
    4. HandlerAdapter-->处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理，并返回一个ModelAndView对象(包含模型数据，逻辑视图名)
    5. ModelAndView的逻辑视图名-->ViewResolver，ViewResoler将把逻辑视图名解析为具体的View。
    6. View-->渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构
    7. 返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户。
1. 什么是[循环依赖](https://blog.csdn.net/chen2526264/article/details/80673598)，怎样检测出循环依赖，Spring循环依赖有几种方式，使用基于setter属性单例注入Bean的循环依赖为什么不会出现问题？  
    答:循环依赖就是N个类中循环嵌套引用，如果在日常开发中我们用new 对象的方式发生这种循环依赖的话程序会在运行时一直循环调用，直至内存溢出报错。当循环依赖的bean都是通过构造器注入依赖的时候，无论这些bean是singleton还是prototype，在获取bean的时候都会失败。
    1. 构造器参数循环依赖  
    Spring容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持在这个池中。  
    因此如果在创建Bean过程中发现自己已经在“当前创建Bean池”里时将抛出BeanCurrentlyInCreationException异常表示循环依赖；而对于创建完毕的Bean将从“当前创建Bean池”中清除掉。
    2. setter方式单例，循环依赖，为什么不会报错？
    ![Bean初始化流程图](https://pic4.zhimg.com/80/v2-9e46e2dea21085b8c8fff852dc5b4ddf_hd.jpg)  
    Spring先是用构造实例化Bean对象 ，此时Spring会将这个实例化结束的对象放到一个Map中，并且Spring提供了获取这个未设置属性的实例化对象引用的方法。当Spring实例化了StudentA、StudentB、StudentC后，紧接着会去设置对象的属性，此时StudentA依赖StudentB，就会去Map中取出存在里面的单例StudentB对象，以此类推，所以不会出来循环的问题。
    容器操作步骤如下:
    1. 尝试创建bean singletonA，发现singletonA是singleton，且不是通过构造器注入依赖，那么先使用默认构造器创建一个A的实例，并保存对它的引用，并且将singletonA标记为“正在创建中的singleton”。然后发现singletonA依赖了singletonB，所以尝试创建singletonB。
    2. 尝试创建bean singletonB，发现singletonB是singleton，且不是通过构造器注入依赖，那么先使用默认构造器创建一个B的实例，并保存对它的引用，并且将singletonB标记为“正在创建中的singleton”。然后发现singletonB依赖了singletonA，所以尝试创建singletonA。
    3. 尝试创建singletonA，注意，这时Spring容器发现singletonA“正在创建中”，那么就不会再去创建singletonA，而是返回容器之前保存了的对singletonA的引用。
    4. 容器将singletonA通过setter方法注入到singletonB，从而singletonB完成创建。
    5. 容器将singletonB通过setter方法注入到singletonA，从而singletonA完成创建。  
    上述步骤，最重要的是第1步和第3步。在第1步中，容器会保存对singletonA的引用，在第3步中，再返回对singletonA的引用，从而可以成功创建那些依赖了singletonA的bean（本例中是singletonB）。这样，循环依赖的环就在singletonA这个点这里被打破。  
    为什么prototype不能成为打破这个环的一个点呢？原因就在于Spring容器只会对singleton保存引用，而对于prototype，并不会对其保存引用，这就导致在第3步中并不能获得之前创建的bean（因为引用不到它）。
1. mysql给离散度低的字段建立索引会出现什么问题？为什么？ 
    答:重复性较强的字段，不适合添加索引。mysql给离散度低的字段，比如性别设置索引，再以性别作为条件进行查询反而会更慢。  
一个表可能会涉及两个数据结构(文件)，一个是表本身，存放表中的数据，另一个是索引。索引是什么？它就是把一个或几个字段（组合索引）按规律排列起来，再附上该字段所在行数据的物理地址（位于表中）。比如我们有个字段是年龄，如果要选取某个年龄段的所有行，那么一般情况下可能需要进行一次全表扫描。但如果以这个年龄段建个索引，那么索引中会按年龄值根据特定数据结构建一个排列，这样在索引中就能迅速定位，不需要进行全表扫描。为什么性别不适合建索引呢？因为访问索引需要付出额外的IO开销，从索引中拿到的只是地址，要想真正访问到数据还是要对表进行一次IO。假如你要从表的100万行数据中取几个数据，那么利用索引迅速定位，访问索引的这IO开销就非常值了。但如果是从100万行数据中取50万行数据，就比如性别字段，那你相对需要访问50万次索引，再访问50万次表，加起来的开销并不会比直接对表进行一次完整扫描小。
1. 单例模式      
    答:涉及到反序列化问题的时候使用枚举方式的单例模式，即解决了
#### 关键字    
- static关键字
    - static的主要目的就是创建独立于具体对象的域变量与方法。 
    - 在加载类的同时加在static修饰的部分静态块。（注意:这个时候，还不存在具体对象，并且这个过程只进行一次）
    - static变量并不是所在类的某个具体对象所有，而是该类的所有对象所共有的，静态变量既能被对象调用，也能直接拿类来调用。  
    - 静态方法和静态变量一样，属于类所有，在类加载的同时执行，不属于某个具体的对象，所有对象均能调用。对于静态方法需要注意以下几点:
        - 它们仅能调用其他的static 方法。
        - 它们只能访问static数据。
        - 它们不能以任何方式引用this 或super。
        - 静态方法一般用于工具类中，可以直接拿类名调用工具方法进行使用。
    - 一般来说，一个普通类是不允许被声明为static的，但是，在内部类中可以将其声明为static的，这个时候，外部类可以直接调用内部类，因为static的内部类是在加载外部类的同时加载的，所以也就是说，并不要实例化外部类就能直接调用静态内部类。
- final:
    - 对于基本类型，final使数值恒定不变；
    - 而对于对象引用，final使引用恒定不变。但是所指向的对象的值可以改变
    - 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。
    - 只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final. 类的private方法会隐式地被指定为final方法。
    - final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 
- finally是异常处理语句结构的一部分，表示总是执行。 
- finalize是Object类的一个方法，在垃圾收集器执行的前会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。 
- transient:
    - java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会[序列化](https://www.cnblogs.com/ysocean/p/6870069.html)到指定的目的地中。
    - 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。
    - transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。
    - 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。
- this关键字在Java中表示以下概念:
    - 调用类中的属性:this.属性;
    - 调用类中的方法:this.方法();
    - 调用类中的构造:this();
    - 表示当前对象
- [Volatile关键字的底层实现原理](http://blog.csdn.net/LiuRenyou/article/details/72808274?locationNum=8&fps=1)

    ![线程工作内存模型](http://img.blog.csdn.net/20170530055214329?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGl1UmVueW91/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
    - volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。
    - 通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。
    - 指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。
    要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。
    - 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义:
        - 1、保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
        - 2、禁止进行指令重排序。
    - 但是用volatile修饰之后就变得不一样了:
        - 第一:使用volatile关键字会强制将修改的值立即写入主存；
        - 第二:使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；
        - 第三:由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。
        - 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。
        - 那么线程1读取到的就是最新的正确的值。